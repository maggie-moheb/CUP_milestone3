import java.io.*;
parser code {:
	String Z = "";
	 int variable_count = -1;
 	 int label_count = -1;
:}

/* Terminals (tokens returned by the scanner). */
terminal			BREAK, DEFAULT, FUNC, CASE, STRUCT, ELSE, PACKAGE, SWITCH, CONST, IF, 
					TYPE, FOR, IMPORT, RETURN, VAR, OR_OP, AND_OP, PLUS, MINUS, OPEN_PARAN, 
					CLOSE_PARAN, OPEN_CURLY, CLOSE_CURLY, OPEN_SQUARE, CLOSE_SQUARE, 
					SEMI_COLON, COMMA, DOT, COLON, COLON_EQUAL, EQUAL, CDOTS, ASTRISK, 
					SHIFT_LEFT, SHIFT_RIGHT, BAR, SLASH, EXCLAMATION, LESS_DASH, AMBERSAND,
					PERCENT, INCREMENT, DECREMENT;
terminal	String	IDENTIFIER, REL_OP, STRING_LIT;	
terminal	String	INT_LIT;

/* Non-terminals */
nonterminal	sourceFile, packageClause, importDecls, importDecl, topLevelDecls,
					topLevelDecl, packageName, importSpecs, importSpec, importPath, 
					optionalSemiColon, declaration, functionDecl, methodDecl, 
					constDecl, varDecl, constSpecs, constSpec, identifierList, 
					expressionList, expression, primaryExpr, 
					unaryExpr, operand, selector, 
					arguments, literal, operandName, methodExpr, basicLit, functionLit, 
					qualifiedIdent, function, signature, functionBody, parameters, result, 
					type, parameterList, parameterDecl, block, statementList, statement, 
					typeName, typeLit, functionType, varSpecs, varSpec, shortVarDecl, functionName, 
					methodName, receiver, receiverType, simpleStmt, returnStmt, breakStmt, 
					ifStmt, switchStmt, forStmt, expressionStmt, incDecStmt, assignment, 
					assignOp, exprSwitchStmt, initStmt, postStmt, condition, forClause, 
					exprCaseClauses, exprCaseClause, exprSwitchCase, assignOpGroup, Group, Group2;

precedence left OR_OP, AND_OP, REL_OP;
precedence left PLUS, MINUS, BAR;
precedence left ASTRISK, SLASH, SHIFT_LEFT, SHIFT_RIGHT, PERCENT, AMBERSAND;
precedence left ASTRISK, SLASH, SHIFT_LEFT, SHIFT_RIGHT, PERCENT, AMBERSAND, PLUS, MINUS, BAR;
precedence left EXCLAMATION, LESS_DASH;
precedence left OPEN_PARAN, CLOSE_PARAN;
precedence left COMMA, SEMI_COLON;
precedence left COLON;

start with sourceFile;
/* The grammar */
sourceFile	::=	packageClause optionalSemiColon importDecls topLevelDecls:d
				{:
					RESULT = d;
				:}
				| packageClause optionalSemiColon importDecls:d
				{:
					RESULT = d;
				:};
				
optionalSemiColon	::=	SEMI_COLON
						{:
							Z +="";
						:}
						| 
						{:
							Z +="";
						:};
										
type	::= typeName
			{:
				Z +="";
			:}
			| typeLit
			{:
				Z +="";
			:};

typeName	::=	IDENTIFIER
				{:
					Z +="";
				:};
				
typeLit	::=functionType
			{:
				Z +="";
			:};
	
functionType ::= FUNC signature
				{:	
					Z +="";
				:};
				
signature	::=	parameters
				{:
					Z +="";
				:}
				| parameters result
				{:
					Z +="";
				:};

result	::=	parameters
			{:
				Z +="";
			:}
			| OPEN_PARAN type CLOSE_PARAN
			{:
				Z +="";
			:};
			
parameters	::=	OPEN_PARAN CLOSE_PARAN
				{:
					Z +="";
				:}
				| OPEN_PARAN parameterList CLOSE_PARAN
				{:
					Z +="";
				:}; 

parameterList	::=	parameterDecl
					{:
						Z +="";
					:}
					| parameterDecl COMMA parameterList
					{:
						Z +="";
					:};
					
parameterDecl	::= identifierList type
					{:
						Z +="push_params: ";
					:}
					| identifierList CDOTS type
					{:
						Z +="";
					:};	
				
methodName	::=	IDENTIFIER
				{:
					Z +="";
				:};
				
block	::= OPEN_CURLY statementList:l CLOSE_CURLY
			{:
			RESULT = l;
			//RESULT = "beginfunc: "+l+"\nend_func;";
			:};
statementList	::=	statement:s statementList:s1
					{:
						RESULT = s+"\n"+s1;
					:}
					| 
					{:
						RESULT ="";
					:};
declaration	::=	constDecl:d SEMI_COLON:sc
				{:
					RESULT = d;
				:}
				| varDecl:vd SEMI_COLON:sc
				{:
					RESULT = vd;
				:};		
			
topLevelDecls	::=	topLevelDecl:d1 topLevelDecls:d2
					{:
						RESULT = d1+""+d2;
					:}
					| topLevelDecl:d
					{:
						RESULT = d;
					:};	
					
topLevelDecl ::=	declaration:d 
					{:
						RESULT = d;
					:}
					| functionDecl:fd optionalSemiColon:osc
					{:
						RESULT = fd;
					:}
					| methodDecl:md optionalSemiColon:osc
					{:
						RESULT = md;
					:};	
					
constDecl	::=	CONST constSpec:c
				{:
					RESULT = c;
				:}
				| CONST OPEN_PARAN constSpecs CLOSE_PARAN
				{:
					Z +="";
				:}
				| CONST OPEN_PARAN CLOSE_PARAN
				{:
					Z +="";
				:};
				
constSpecs	::=	constSpec SEMI_COLON constSpecs
				{:
					Z +="";
				:}
				| constSpec SEMI_COLON
				{:
					Z +="";
				:};
				
constSpec	::=	IDENTIFIER:i
				{:
					RESULT = i;
				:}
				| IDENTIFIER:i EQUAL expression:e
				{:
					RESULT = i +" = " +e;
				:}
				| IDENTIFIER:i type EQUAL expression:e
				{:
					RESULT = i+" = "+e;
				:};

identifierList	::=	IDENTIFIER:i
					{:
						RESULT = i;
					:}
					| IDENTIFIER:i COMMA identifierList:i1
					{:
						RESULT = i + "" + i1;
					:};		
					
expressionList	::=	expression:e
					{:
						////System.out.println("expr_l " + e);
						RESULT = e;
					:}
					| expression:e COMMA expressionList:e1
					{:
						RESULT = e+"\n"+e1;
					:};


expression	::=	unaryExpr:u
				{:
					//System.out.println("expression " + u);
					RESULT = u;
				:}
				| expression:e1 Group:o expression:e2
				{:
					RESULT = "";
					String fstoperand = e1.toString();
					String sndoperand = e2.toString();
					if(e1.toString().length() >=3) {
						RESULT += e1.toString();
						fstoperand = e1.toString().substring(1,3);
					}
					if(e2.toString().length() >=3) {
						RESULT += e2.toString();
						sndoperand = e2.toString().substring(1,3);
					}
					variable_count++;
					RESULT += "\nt"+variable_count+" = "+fstoperand +""+ o + ""+ sndoperand;
				:};

Group ::= REL_OP:a
		{:
			RESULT = a;
		:} 
		| OR_OP:a
		{:
			RESULT = a;
		:} 
		| AND_OP:a
		{:
			RESULT = a;
		:} 
		| PLUS:a
		{:
			RESULT = a;
		:} 
		| MINUS:a
		{:
			RESULT = a;
		:}
		| ASTRISK:a
		{:
			RESULT = a;
		:} 
		| SLASH:a
		{: 
			RESULT = a;
		:}
		| PERCENT:a
		{:
			RESULT = a;
		:}
		| SHIFT_LEFT:a
		{:
			RESULT = a;
		:}
		| SHIFT_RIGHT:a
		{:
			RESULT = a;
		
		:}
		| AMBERSAND:a
		{:
			RESULT = a;
		:}
		| EXCLAMATION:a 
		{:
			RESULT = a;
		:};
		
unaryExpr	::=	primaryExpr:p
				{:
					//System.out.println("unaryExpr " + p);
					RESULT = p;
				:}
				| Group2:o unaryExpr:e
				{:
					RESULT = o+""+e;
				:};	

Group2 ::= MINUS:a {:
					RESULT = a;
				:} 
				| EXCLAMATION:a {:
					RESULT = a;
				:}
				| ASTRISK:a {:
					RESULT = a;
				:};
			
varDecl	::=	VAR varSpec:vs 
			{:
				RESULT = vs + "t" + variable_count;
			:}
			| VAR OPEN_PARAN varSpecs CLOSE_PARAN
			{:
				Z +="";
			:};				

varSpecs	::= varSpec:v SEMI_COLON varSpecs
				{:
					RESULT = v;
				:}
				| 
				{:
					RESULT="";
				:};
				
varSpec	::= IDENTIFIER:i EQUAL expression:e
			{:
				RESULT = e + "\n" + i + " = ";
			:}
			| IDENTIFIER:i type:t
			{:
				RESULT = i+" "+t;
			:}
			| IDENTIFIER:i type:t EQUAL expression:e
			{:
				RESULT = i+" "+t+" "+e;
			:};
		
shortVarDecl	::= identifierList:i COLON_EQUAL expression:e
					{:
						RESULT = e +"\n"+ i + " = " + e.toString().substring(1,3);
					:};
	
functionDecl	::= FUNC functionName:f function:f2
					{:
						RESULT = "\n"+ f +"\n" +f2;
					:}
					| FUNC functionName signature
					{:
						Z +="";
					:};

functionName	::= IDENTIFIER:i
					{:
						RESULT = i+":";
					:};

function	::=	signature functionBody:b
				{:
					RESULT = b;
				:};

functionBody	::= block:b
					{:
						RESULT = "beginfunc: "+b+"\nend_func;";
					:};

methodDecl	::= FUNC receiver methodName function
				{:
					Z +="";
				:}
				| FUNC receiver methodName signature
				{:
					Z +="";
				:};
				
receiver	::= parameters
				{:
					Z +="";
				:};

operand	::=	literal:l
			{:
				//System.out.println("literal "+l);
				RESULT = l;
			:}
			| operandName:o
			{:
				//System.out.println("operandName " + o);
				RESULT = o;
			:}
			| methodExpr:me
			{:
				RESULT = me;
			:}
			| OPEN_PARAN expression:e CLOSE_PARAN
			{:
				RESULT = e;
			:};

literal	::=	basicLit:b
			{:
				////System.out.println("basicLit: " + b);
				RESULT = b;
			:}
			| functionLit:f
			{:
				RESULT = f;
			:};

basicLit	::=	INT_LIT:i
				{:
					RESULT = i;
				:}
				| STRING_LIT:s_l 
				{:
					RESULT = s_l;
				:};

operandName	::=	IDENTIFIER:i
				{:
					RESULT = i;
				:}
				| qualifiedIdent:i
				{:
					RESULT = i;
				:};

qualifiedIdent	::=	DOT packageName DOT IDENTIFIER:i
					{:
						variable_count++;
						RESULT = "t"+ variable_count+ "= call "+i + "\n"+"pop_params;";
					:};

functionLit	::=	FUNC function:f
				{:
					RESULT = f;
				:};

primaryExpr	::=	operand:o
				{:		
					//System.out.println("operand " + o);	
					RESULT = o;
				:}
				| primaryExpr:p selector:s
				{:	
					RESULT = p+""+s;
				:}
				| primaryExpr:p arguments:a
				{:			
					RESULT = a+"\n"+ p ;
				:};

selector	::= DOT IDENTIFIER:i
				{:
					RESULT = i;
				:};

arguments	::=	OPEN_PARAN CLOSE_PARAN
				{:
					RESULT ="";
				:}
				| OPEN_PARAN expressionList:e CLOSE_PARAN
				{:
					RESULT="\npush_params: "+e;
				:}
				| OPEN_PARAN TYPE type COMMA expressionList:e CLOSE_PARAN
				{:
					RESULT = e;
				:};

methodExpr	::=	DOT receiverType DOT methodName
				{:
					Z +="";
				:};


receiverType	::=	OPEN_PARAN ASTRISK typeName CLOSE_PARAN
					{:
						Z +="";
					:}
					| OPEN_PARAN typeName CLOSE_PARAN
					{:
						Z +="";
					:};
					
statement	::=	declaration:d
				{:
					RESULT = d;
				:}
				| simpleStmt:d SEMI_COLON
				{:				
					RESULT = d;
				:}
				| returnStmt:d SEMI_COLON
				{:
					RESULT ="";
				:}
				| breakStmt SEMI_COLON
				{:
					RESULT ="";
				:}
				| block:b optionalSemiColon
				{:
					RESULT = b;
				:}
				| ifStmt:is optionalSemiColon
				{:
					RESULT = is + "\nIf t" + variable_count+ " Goto L"+ ++label_count+"\nGoto L"
						+ ++label_count + "\nL"+ (label_count - 1)+":\n";
				:}
				| switchStmt optionalSemiColon
				{:
					Z +="";
				:}
				| forStmt optionalSemiColon
				{:
					Z +="";
				:};

simpleStmt	::= expressionStmt:a
				{:
					RESULT = a;
				:}
				| incDecStmt:a
				{:
					RESULT = a;
				:}
				| assignment:a
				{:
					RESULT = a;
				:}
				| shortVarDecl:a
				{:
					RESULT = a;
				:};


expressionStmt	::= expression:e
					{:
						RESULT = e;
					:};

incDecStmt	::= expression INCREMENT
				{:
					Z +="";
				:}
				| expression DECREMENT
				{:
					Z +="";
				:};

assignment	::=	expressionList:e assignOp:o expressionList:e2
				{:
					RESULT = e+" "+o+"\n"+e2;
					Z +="";
				:};

assignOp	::=	assignOpGroup EQUAL{:
				:};

assignOpGroup ::= PLUS{:
				:}
				|MINUS{:
				:}
				|ASTRISK{:
				:}
				|SLASH{:
				:}
				|SHIFT_LEFT{:
				:}
				|SHIFT_RIGHT{:
				:}
				|{:
				:};

ifStmt	::=	IF expression:e block:b
			{:
				//System.out.println("da el block: " + b);
				RESULT = e + "" + b;
			:}
			| IF simpleStmt:s SEMI_COLON expression:e block:b
			{:
				RESULT = s + "" + e + "" + b;
			:}
			| IF expression block ELSE ifStmt
			{:
				Z +="";
			:}
			| IF expression block ELSE block
			{:
				Z +="";
			:}
			| IF simpleStmt:s SEMI_COLON expression block ELSE ifStmt
			{:
				RESULT = s;
				Z +="";
			:}
			| IF simpleStmt:s SEMI_COLON expression block ELSE block
			{:
				RESULT= s;			
			:};

switchStmt	::=	exprSwitchStmt
				{:
					Z +="";
				:};

exprSwitchStmt	::= SWITCH OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
						Z +="";
					:}
					| SWITCH  simpleStmt:s SEMI_COLON OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
						RESULT = s;
					:}
					| SWITCH expression OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
						Z +="";
					:}
					| SWITCH simpleStmt:s SEMI_COLON expression OPEN_CURLY exprCaseClauses CLOSE_CURLY
					{:
						RESULT = s;
					:};


exprCaseClauses	::=	exprCaseClause exprCaseClauses
					{:
						Z +="";
					:}
					| 
					{:
						Z +="";
					:};

exprCaseClause	::= exprSwitchCase COLON statementList
					{:
						Z +="";
					:};

exprSwitchCase	::=	CASE expression
					{:
						Z +="";
					:}
					| DEFAULT
					{:
						Z +="";
					:};

forStmt	::=	 FOR forClause block
			{:
				Z +="";
			:};

forClause	::=	initStmt SEMI_COLON condition SEMI_COLON postStmt
				{:
					Z +="";
				:};

condition	::=	expression
				{:
					Z +="";
				:};

initStmt	::=	simpleStmt:s
				{:
					RESULT = s;
				:};

postStmt	::=	simpleStmt:s
				{:
					RESULT = s;
				:};

returnStmt	::=	RETURN
				{:
					Z +="";
				:}
				| RETURN expressionList
				{:
					Z +="";
				:};

breakStmt	::=	BREAK
				{:
					Z +="";
				:};

packageClause	::=	PACKAGE packageName
					{:
						Z +="";
					:};

packageName	::=	IDENTIFIER
				{:
					Z +="";
				:};

importDecls	::=	importDecl optionalSemiColon importDecls
				{:
					Z +="";
				:}
				|
				{:
					Z +="";
				:};

importDecl	::=	IMPORT	importSpec
				{:
					Z +="";
				:}
				| IMPORT OPEN_PARAN importSpecs CLOSE_PARAN
				{:
					Z +="";
				:};

importSpecs	::=	importSpec optionalSemiColon importSpecs
				{:
					Z +="";
				:}
				| 
				{:
					Z +="";
				:};

importSpec	::=	importPath
				{:
					Z +="";
				:}
				| DOT importPath
				{:
					Z +="";
				:}
				| packageName importPath
				{:
					Z +="";
				:};

importPath	::=	STRING_LIT
				{:
					Z +="";
				:};
	